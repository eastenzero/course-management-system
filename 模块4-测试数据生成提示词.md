# 模块4：大规模测试数据生成提示词

## 数据生成目标

你是一位数据工程师，需要为校园课程表管理系统生成大规模、真实、多样化的测试数据，以充分体现智能排课算法的必要性和优越性。数据应当具备以下特征：

- **规模化**: 支持大型高校的数据规模
- **真实性**: 符合实际高校的业务场景
- **复杂性**: 包含各种复杂的约束和冲突情况
- **多样性**: 覆盖不同类型的课程和用户场景

## 数据规模设计

### 基础数据规模
```python
# 大型综合性大学数据规模
DATA_SCALE = {
    'students': 25000,        # 学生总数
    'teachers': 1500,         # 教师总数
    'courses': 3000,          # 课程总数
    'classrooms': 300,        # 教室总数
    'departments': 20,        # 院系数量
    'majors': 80,            # 专业数量
    'semesters': 8,          # 学期数量
    'time_slots': 12,        # 每日时间段数
    'weeks_per_semester': 18, # 每学期周数
}

# 中型大学数据规模
MEDIUM_SCALE = {
    'students': 12000,
    'teachers': 800,
    'courses': 1500,
    'classrooms': 150,
    'departments': 12,
    'majors': 40,
    'semesters': 8,
    'time_slots': 10,
    'weeks_per_semester': 16,
}

# 小型学院数据规模
SMALL_SCALE = {
    'students': 5000,
    'teachers': 300,
    'courses': 600,
    'classrooms': 60,
    'departments': 6,
    'majors': 20,
    'semesters': 8,
    'time_slots': 8,
    'weeks_per_semester': 16,
}
```

## 核心数据生成模块

### 模块1：院系专业数据生成

```python
import random
import faker
from typing import List, Dict
from dataclasses import dataclass
from datetime import datetime, timedelta

class DepartmentGenerator:
    """院系数据生成器"""
    
    def __init__(self):
        self.fake = faker.Faker('zh_CN')
        
        # 真实的院系名称模板
        self.department_templates = [
            "计算机科学与技术学院", "软件学院", "信息工程学院",
            "电子信息工程学院", "机械工程学院", "材料科学与工程学院",
            "化学化工学院", "生物科学学院", "数学与统计学院",
            "物理学院", "经济管理学院", "工商管理学院",
            "外国语学院", "文学院", "法学院",
            "医学院", "护理学院", "药学院",
            "建筑学院", "土木工程学院"
        ]
        
        # 专业名称模板
        self.major_templates = {
            "计算机科学与技术学院": [
                "计算机科学与技术", "软件工程", "网络工程", 
                "信息安全", "数据科学与大数据技术", "人工智能"
            ],
            "电子信息工程学院": [
                "电子信息工程", "通信工程", "电子科学与技术",
                "微电子科学与工程", "光电信息科学与工程"
            ],
            "机械工程学院": [
                "机械设计制造及其自动化", "机械电子工程", "车辆工程",
                "工业设计", "过程装备与控制工程"
            ],
            "经济管理学院": [
                "工商管理", "市场营销", "会计学", "财务管理",
                "人力资源管理", "国际经济与贸易", "金融学"
            ],
            "医学院": [
                "临床医学", "口腔医学", "预防医学", "医学影像学",
                "麻醉学", "精神医学"
            ]
        }
    
    def generate_departments(self, count: int) -> List[Dict]:
        """生成院系数据"""
        departments = []
        selected_names = random.sample(self.department_templates, min(count, len(self.department_templates)))
        
        for i, name in enumerate(selected_names):
            department = {
                'id': i + 1,
                'name': name,
                'code': f"DEPT{i+1:03d}",
                'dean': self.fake.name(),
                'phone': self.fake.phone_number(),
                'email': f"dean{i+1}@university.edu.cn",
                'address': f"{name}大楼",
                'established_year': random.randint(1950, 2020),
                'description': f"{name}致力于培养高素质的专业人才",
                'created_at': self.fake.date_time_between(start_date='-5y', end_date='now')
            }
            departments.append(department)
        
        return departments
    
    def generate_majors(self, departments: List[Dict]) -> List[Dict]:
        """生成专业数据"""
        majors = []
        major_id = 1
        
        for dept in departments:
            dept_name = dept['name']
            if dept_name in self.major_templates:
                major_names = self.major_templates[dept_name]
            else:
                # 为其他院系生成通用专业名称
                major_names = [f"{dept_name.replace('学院', '')}专业{i+1}" for i in range(3)]
            
            for major_name in major_names:
                major = {
                    'id': major_id,
                    'name': major_name,
                    'code': f"MAJ{major_id:03d}",
                    'department_id': dept['id'],
                    'degree_type': random.choice(['本科', '硕士', '博士']),
                    'duration': random.choice([4, 3, 3]) if major['degree_type'] == '本科' else random.choice([2, 3]),
                    'total_credits': random.randint(140, 180) if major['degree_type'] == '本科' else random.randint(30, 50),
                    'description': f"{major_name}专业培养方案",
                    'created_at': self.fake.date_time_between(start_date='-3y', end_date='now')
                }
                majors.append(major)
                major_id += 1
        
        return majors
```

### 模块2：用户数据生成

```python
class UserGenerator:
    """用户数据生成器"""
    
    def __init__(self):
        self.fake = faker.Faker('zh_CN')
        
        # 真实姓名库
        self.surnames = ['王', '李', '张', '刘', '陈', '杨', '赵', '黄', '周', '吴',
                        '徐', '孙', '胡', '朱', '高', '林', '何', '郭', '马', '罗']
        
        self.given_names = ['伟', '芳', '娜', '秀英', '敏', '静', '丽', '强', '磊', '军',
                           '洋', '勇', '艳', '杰', '娟', '涛', '明', '超', '秀兰', '霞']
    
    def generate_students(self, count: int, majors: List[Dict]) -> List[Dict]:
        """生成学生数据"""
        students = []
        
        for i in range(count):
            major = random.choice(majors)
            grade = random.randint(2020, 2024)  # 入学年份
            
            student = {
                'id': i + 1,
                'student_id': f"{grade}{major['department_id']:02d}{i+1:04d}",
                'username': f"student{i+1:06d}",
                'password': 'hashed_password_123',
                'name': self.generate_chinese_name(),
                'gender': random.choice(['男', '女']),
                'birth_date': self.fake.date_of_birth(minimum_age=18, maximum_age=25),
                'phone': self.fake.phone_number(),
                'email': f"student{i+1}@university.edu.cn",
                'major_id': major['id'],
                'grade': grade,
                'class_number': random.randint(1, 10),
                'status': random.choice(['在读', '休学', '毕业'], weights=[0.9, 0.05, 0.05]),
                'gpa': round(random.uniform(2.0, 4.0), 2),
                'total_credits': random.randint(0, 150),
                'address': self.fake.address(),
                'emergency_contact': self.fake.name(),
                'emergency_phone': self.fake.phone_number(),
                'created_at': self.fake.date_time_between(start_date='-4y', end_date='now')
            }
            students.append(student)
        
        return students
    
    def generate_teachers(self, count: int, departments: List[Dict]) -> List[Dict]:
        """生成教师数据"""
        teachers = []
        
        # 教师职称分布
        titles = ['教授', '副教授', '讲师', '助教']
        title_weights = [0.15, 0.25, 0.45, 0.15]
        
        # 学历分布
        degrees = ['博士', '硕士', '学士']
        degree_weights = [0.7, 0.25, 0.05]
        
        for i in range(count):
            department = random.choice(departments)
            
            teacher = {
                'id': i + 1,
                'employee_id': f"T{i+1:06d}",
                'username': f"teacher{i+1:06d}",
                'password': 'hashed_password_123',
                'name': self.generate_chinese_name(),
                'gender': random.choice(['男', '女']),
                'birth_date': self.fake.date_of_birth(minimum_age=25, maximum_age=65),
                'phone': self.fake.phone_number(),
                'email': f"teacher{i+1}@university.edu.cn",
                'department_id': department['id'],
                'title': random.choices(titles, weights=title_weights)[0],
                'degree': random.choices(degrees, weights=degree_weights)[0],
                'hire_date': self.fake.date_between(start_date='-20y', end_date='now'),
                'office_location': f"{department['name']}{random.randint(101, 999)}室",
                'research_areas': self.generate_research_areas(),
                'max_weekly_hours': random.randint(12, 20),
                'status': random.choice(['在职', '退休', '离职'], weights=[0.9, 0.08, 0.02]),
                'salary': random.randint(8000, 25000),
                'created_at': self.fake.date_time_between(start_date='-5y', end_date='now')
            }
            teachers.append(teacher)
        
        return teachers
    
    def generate_chinese_name(self) -> str:
        """生成中文姓名"""
        surname = random.choice(self.surnames)
        given_name = ''.join(random.choices(self.given_names, k=random.randint(1, 2)))
        return surname + given_name
    
    def generate_research_areas(self) -> str:
        """生成研究方向"""
        areas = [
            "机器学习", "深度学习", "计算机视觉", "自然语言处理",
            "数据挖掘", "软件工程", "网络安全", "分布式系统",
            "人工智能", "算法设计", "数据库系统", "云计算"
        ]
        return ', '.join(random.sample(areas, random.randint(1, 3)))
```

### 模块3：课程数据生成

```python
class CourseGenerator:
    """课程数据生成器"""
    
    def __init__(self):
        self.fake = faker.Faker('zh_CN')
        
        # 课程名称模板
        self.course_templates = {
            "计算机": [
                "数据结构与算法", "计算机网络", "操作系统", "数据库系统",
                "软件工程", "编译原理", "计算机组成原理", "人工智能导论",
                "机器学习", "深度学习", "计算机图形学", "网络安全",
                "分布式系统", "云计算技术", "大数据处理", "区块链技术"
            ],
            "数学": [
                "高等数学", "线性代数", "概率论与数理统计", "离散数学",
                "数值分析", "运筹学", "数学建模", "复变函数",
                "实变函数", "泛函分析", "微分方程", "拓扑学"
            ],
            "物理": [
                "大学物理", "理论力学", "电磁学", "热力学与统计物理",
                "量子力学", "固体物理", "光学", "原子物理学",
                "核物理", "粒子物理", "天体物理", "凝聚态物理"
            ],
            "化学": [
                "无机化学", "有机化学", "物理化学", "分析化学",
                "生物化学", "高分子化学", "材料化学", "环境化学",
                "药物化学", "化工原理", "化学工程", "催化化学"
            ],
            "经济": [
                "微观经济学", "宏观经济学", "计量经济学", "国际经济学",
                "货币银行学", "财政学", "投资学", "公司金融",
                "证券投资", "期货与期权", "风险管理", "行为金融学"
            ],
            "管理": [
                "管理学原理", "组织行为学", "人力资源管理", "市场营销",
                "战略管理", "运营管理", "项目管理", "质量管理",
                "供应链管理", "创新管理", "领导力", "企业文化"
            ]
        }
        
        # 课程类型
        self.course_types = ['必修', '选修', '限选', '通识']
        self.course_type_weights = [0.4, 0.3, 0.2, 0.1]
    
    def generate_courses(self, count: int, departments: List[Dict], teachers: List[Dict]) -> List[Dict]:
        """生成课程数据"""
        courses = []
        
        for i in range(count):
            department = random.choice(departments)
            dept_name = department['name']
            
            # 根据院系选择课程类别
            if "计算机" in dept_name or "软件" in dept_name:
                category = "计算机"
            elif "数学" in dept_name or "统计" in dept_name:
                category = "数学"
            elif "物理" in dept_name:
                category = "物理"
            elif "化学" in dept_name or "化工" in dept_name:
                category = "化学"
            elif "经济" in dept_name:
                category = "经济"
            elif "管理" in dept_name:
                category = "管理"
            else:
                category = random.choice(list(self.course_templates.keys()))
            
            course_name = random.choice(self.course_templates[category])
            
            # 为课程分配教师
            dept_teachers = [t for t in teachers if t['department_id'] == department['id']]
            assigned_teachers = random.sample(dept_teachers, random.randint(1, min(3, len(dept_teachers))))
            
            course = {
                'id': i + 1,
                'code': f"{department['code']}{i+1:04d}",
                'name': course_name,
                'english_name': self.translate_to_english(course_name),
                'department_id': department['id'],
                'credits': random.choices([1, 2, 3, 4, 5], weights=[0.1, 0.2, 0.4, 0.25, 0.05])[0],
                'hours': random.randint(16, 80),
                'course_type': random.choices(self.course_types, weights=self.course_type_weights)[0],
                'semester': random.randint(1, 8),
                'max_students': random.randint(30, 200),
                'min_students': random.randint(10, 30),
                'description': f"{course_name}课程介绍",
                'objectives': f"通过学习{course_name}，学生将掌握相关理论和实践技能",
                'prerequisites': self.generate_prerequisites(i, courses),
                'assessment_method': random.choice(['考试', '考查', '论文', '项目']),
                'textbook': f"{course_name}教程",
                'reference_books': f"{course_name}参考书目",
                'teacher_ids': [t['id'] for t in assigned_teachers],
                'is_active': random.choice([True, False], weights=[0.95, 0.05]),
                'created_at': self.fake.date_time_between(start_date='-2y', end_date='now')
            }
            courses.append(course)
        
        return courses
    
    def generate_prerequisites(self, current_index: int, existing_courses: List[Dict]) -> List[int]:
        """生成先修课程"""
        if current_index < 5:  # 前几门课程没有先修课程
            return []
        
        # 随机选择0-2门先修课程
        num_prerequisites = random.choices([0, 1, 2], weights=[0.6, 0.3, 0.1])[0]
        if num_prerequisites == 0:
            return []
        
        available_courses = existing_courses[:current_index]
        if len(available_courses) < num_prerequisites:
            return [c['id'] for c in available_courses]
        
        prerequisites = random.sample(available_courses, num_prerequisites)
        return [c['id'] for c in prerequisites]
    
    def translate_to_english(self, chinese_name: str) -> str:
        """中文课程名翻译为英文（简化版）"""
        translations = {
            "数据结构与算法": "Data Structures and Algorithms",
            "计算机网络": "Computer Networks",
            "操作系统": "Operating Systems",
            "数据库系统": "Database Systems",
            "软件工程": "Software Engineering",
            "高等数学": "Advanced Mathematics",
            "线性代数": "Linear Algebra",
            "概率论与数理统计": "Probability and Statistics",
            "大学物理": "College Physics",
            "微观经济学": "Microeconomics",
            "宏观经济学": "Macroeconomics"
        }
        return translations.get(chinese_name, f"{chinese_name} (English)")
```

### 模块4：教室与时间数据生成

```python
class FacilityGenerator:
    """设施数据生成器"""
    
    def __init__(self):
        self.fake = faker.Faker('zh_CN')
        
        # 教学楼名称
        self.building_names = [
            "文科楼", "理科楼", "工科楼", "实验楼", "图书馆",
            "行政楼", "学生活动中心", "体育馆", "艺术楼", "医学楼"
        ]
        
        # 教室类型
        self.room_types = {
            "普通教室": {"capacity_range": (30, 150), "equipment": ["投影仪", "音响", "黑板"]},
            "多媒体教室": {"capacity_range": (50, 200), "equipment": ["投影仪", "音响", "电脑", "网络"]},
            "实验室": {"capacity_range": (20, 40), "equipment": ["实验台", "仪器设备", "通风系统"]},
            "机房": {"capacity_range": (30, 60), "equipment": ["电脑", "网络", "投影仪", "空调"]},
            "阶梯教室": {"capacity_range": (100, 500), "equipment": ["投影仪", "音响", "话筒", "灯光"]},
            "研讨室": {"capacity_range": (10, 30), "equipment": ["白板", "投影仪", "圆桌"]}
        }
    
    def generate_classrooms(self, count: int) -> List[Dict]:
        """生成教室数据"""
        classrooms = []
        
        for i in range(count):
            building = random.choice(self.building_names)
            floor = random.randint(1, 6)
            room_number = f"{floor}{random.randint(10, 99):02d}"
            
            room_type = random.choice(list(self.room_types.keys()))
            type_info = self.room_types[room_type]
            
            capacity = random.randint(*type_info["capacity_range"])
            equipment = type_info["equipment"].copy()
            
            # 随机添加额外设备
            extra_equipment = ["空调", "暖气", "窗帘", "WiFi", "监控"]
            equipment.extend(random.sample(extra_equipment, random.randint(0, 3)))
            
            classroom = {
                'id': i + 1,
                'building': building,
                'floor': floor,
                'room_number': room_number,
                'full_name': f"{building}{room_number}",
                'room_type': room_type,
                'capacity': capacity,
                'area': random.randint(50, 300),  # 平方米
                'equipment': equipment,
                'is_available': random.choice([True, False], weights=[0.95, 0.05]),
                'maintenance_status': random.choice(['正常', '维修中', '待维修'], weights=[0.9, 0.05, 0.05]),
                'booking_rules': "需提前预约",
                'usage_fee': random.randint(0, 100) if room_type in ["多媒体教室", "机房"] else 0,
                'manager': self.fake.name(),
                'manager_phone': self.fake.phone_number(),
                'description': f"{room_type}，位于{building}{floor}楼",
                'created_at': self.fake.date_time_between(start_date='-5y', end_date='now')
            }
            classrooms.append(classroom)
        
        return classrooms
    
    def generate_time_slots(self) -> List[Dict]:
        """生成时间段数据"""
        time_slots = []
        
        # 标准时间段配置
        standard_slots = [
            {"name": "第1节", "start": "08:00", "end": "08:45"},
            {"name": "第2节", "start": "08:55", "end": "09:40"},
            {"name": "第3节", "start": "10:00", "end": "10:45"},
            {"name": "第4节", "start": "10:55", "end": "11:40"},
            {"name": "第5节", "start": "14:00", "end": "14:45"},
            {"name": "第6节", "start": "14:55", "end": "15:40"},
            {"name": "第7节", "start": "16:00", "end": "16:45"},
            {"name": "第8节", "start": "16:55", "end": "17:40"},
            {"name": "第9节", "start": "19:00", "end": "19:45"},
            {"name": "第10节", "start": "19:55", "end": "20:40"},
        ]
        
        for i, slot in enumerate(standard_slots):
            time_slot = {
                'id': i + 1,
                'name': slot['name'],
                'start_time': slot['start'],
                'end_time': slot['end'],
                'duration': 45,  # 分钟
                'break_time': 10 if i < 9 else 0,  # 课间休息时间
                'period': self.get_period(slot['start']),
                'is_active': True,
                'order': i + 1,
                'description': f"{slot['name']} ({slot['start']}-{slot['end']})"
            }
            time_slots.append(time_slot)
        
        return time_slots
    
    def get_period(self, start_time: str) -> str:
        """根据开始时间确定时段"""
        hour = int(start_time.split(':')[0])
        if hour < 12:
            return "上午"
        elif hour < 18:
            return "下午"
        else:
            return "晚上"
```

### 模块5：复杂场景数据生成

```python
class ComplexScenarioGenerator:
    """复杂场景数据生成器"""
    
    def __init__(self):
        self.fake = faker.Faker('zh_CN')
    
    def generate_enrollment_data(self, students: List[Dict], courses: List[Dict]) -> List[Dict]:
        """生成选课数据 - 创造复杂的选课场景"""
        enrollments = []
        enrollment_id = 1
        
        for student in students:
            # 每个学生选择5-8门课程
            num_courses = random.randint(5, 8)
            
            # 根据学生专业和年级选择合适的课程
            suitable_courses = self.filter_suitable_courses(student, courses)
            
            if len(suitable_courses) < num_courses:
                selected_courses = suitable_courses
            else:
                selected_courses = random.sample(suitable_courses, num_courses)
            
            for course in selected_courses:
                enrollment = {
                    'id': enrollment_id,
                    'student_id': student['id'],
                    'course_id': course['id'],
                    'semester': f"{random.randint(2023, 2024)}-{random.randint(1, 2)}",
                    'status': random.choice(['已选', '待审核', '已退课'], weights=[0.85, 0.1, 0.05]),
                    'grade': random.choice([None, random.randint(60, 100)], weights=[0.7, 0.3]),
                    'attendance_rate': random.uniform(0.7, 1.0),
                    'enrollment_date': self.fake.date_time_between(start_date='-1y', end_date='now'),
                    'created_at': self.fake.date_time_between(start_date='-1y', end_date='now')
                }
                enrollments.append(enrollment)
                enrollment_id += 1
        
        return enrollments
    
    def filter_suitable_courses(self, student: Dict, courses: List[Dict]) -> List[Dict]:
        """根据学生情况筛选合适的课程"""
        suitable_courses = []
        
        for course in courses:
            # 检查学期匹配
            if course['semester'] <= student['grade'] - 2020 + 1:
                # 检查是否为本专业课程或通识课程
                if (course['department_id'] == student.get('major', {}).get('department_id') or 
                    course['course_type'] == '通识'):
                    suitable_courses.append(course)
        
        return suitable_courses
    
    def generate_teacher_preferences(self, teachers: List[Dict]) -> List[Dict]:
        """生成教师时间偏好数据"""
        preferences = []
        
        for teacher in teachers:
            # 生成每个教师的时间偏好
            for day in range(1, 6):  # 周一到周五
                for time_slot in range(1, 11):  # 10个时间段
                    
                    # 生成偏好分数 (0-1之间)
                    preference_score = self.calculate_preference_score(day, time_slot, teacher)
                    
                    preference = {
                        'teacher_id': teacher['id'],
                        'day_of_week': day,
                        'time_slot': time_slot,
                        'preference_score': preference_score,
                        'reason': self.generate_preference_reason(preference_score),
                        'is_available': preference_score > 0.2,  # 低于0.2认为不可用
                        'created_at': self.fake.date_time_between(start_date='-1y', end_date='now')
                    }
                    preferences.append(preference)
        
        return preferences
    
    def calculate_preference_score(self, day: int, time_slot: int, teacher: Dict) -> float:
        """计算教师时间偏好分数"""
        base_score = 0.5
        
        # 年龄因素：年长教师偏好上午时间
        age = 2024 - teacher['birth_date'].year
        if age > 50 and time_slot <= 4:  # 上午时间
            base_score += 0.3
        elif age < 35 and time_slot >= 7:  # 年轻教师可以接受晚上
            base_score += 0.2
        
        # 职称因素：教授偏好较少的课时
        if teacher['title'] == '教授' and random.random() < 0.3:
            base_score -= 0.2
        
        # 随机因素
        base_score += random.uniform(-0.2, 0.2)
        
        return max(0.0, min(1.0, base_score))
    
    def generate_preference_reason(self, score: float) -> str:
        """生成偏好原因"""
        if score > 0.8:
            return random.choice(["最佳时间", "精力充沛", "学生注意力集中"])
        elif score > 0.6:
            return random.choice(["较好时间", "可以接受", "时间合适"])
        elif score > 0.4:
            return random.choice(["一般时间", "勉强可以", "需要调整"])
        elif score > 0.2:
            return random.choice(["不太理想", "尽量避免", "影响效果"])
        else:
            return random.choice(["不可用", "有其他安排", "身体原因"])
    
    def generate_conflict_scenarios(self, courses: List[Dict], 
                                  teachers: List[Dict], 
                                  classrooms: List[Dict]) -> List[Dict]:
        """生成冲突场景数据"""
        conflicts = []
        
        # 故意创造一些冲突情况来测试算法
        
        # 1. 热门教师冲突
        popular_teachers = random.sample(teachers, min(10, len(teachers)))
        for teacher in popular_teachers:
            teacher_courses = [c for c in courses if teacher['id'] in c.get('teacher_ids', [])]
            if len(teacher_courses) > 3:  # 课程较多的教师
                conflicts.append({
                    'type': 'teacher_overload',
                    'teacher_id': teacher['id'],
                    'course_count': len(teacher_courses),
                    'description': f"教师{teacher['name']}课程安排过多"
                })
        
        # 2. 热门教室冲突
        popular_classrooms = [c for c in classrooms if c['capacity'] > 100]
        for classroom in popular_classrooms[:5]:
            conflicts.append({
                'type': 'classroom_demand',
                'classroom_id': classroom['id'],
                'demand_level': 'high',
                'description': f"教室{classroom['full_name']}需求量大"
            })
        
        # 3. 时间段冲突
        peak_hours = [3, 4, 6, 7]  # 热门时间段
        for hour in peak_hours:
            conflicts.append({
                'type': 'time_slot_conflict',
                'time_slot': hour,
                'demand_level': 'high',
                'description': f"第{hour}节课时间段需求量大"
            })
        
        return conflicts
```

### 模块6：数据导出与验证

```python
class DataExporter:
    """数据导出器"""
    
    def __init__(self):
        self.fake = faker.Faker('zh_CN')
    
    def export_to_sql(self, data_dict: Dict, output_file: str):
        """导出为SQL插入语句"""
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("-- 校园课程表管理系统测试数据\n")
            f.write(f"-- 生成时间: {datetime.now()}\n\n")
            
            for table_name, records in data_dict.items():
                f.write(f"-- {table_name} 表数据\n")
                if records:
                    self.write_insert_statements(f, table_name, records)
                f.write("\n")
    
    def export_to_json(self, data_dict: Dict, output_file: str):
        """导出为JSON格式"""
        import json
        
        # 处理日期时间序列化
        def json_serializer(obj):
            if isinstance(obj, datetime):
                return obj.isoformat()
            raise TypeError(f"Object of type {type(obj)} is not JSON serializable")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(data_dict, f, ensure_ascii=False, indent=2, default=json_serializer)
    
    def validate_data_integrity(self, data_dict: Dict) -> Dict[str, List[str]]:
        """验证数据完整性"""
        errors = {}
        
        # 验证外键关系
        departments = {d['id']: d for d in data_dict.get('departments', [])}
        majors = data_dict.get('majors', [])
        students = data_dict.get('students', [])
        teachers = data_dict.get('teachers', [])
        courses = data_dict.get('courses', [])
        
        # 检查专业的院系ID是否存在
        for major in majors:
            if major['department_id'] not in departments:
                errors.setdefault('majors', []).append(
                    f"专业 {major['name']} 的院系ID {major['department_id']} 不存在"
                )
        
        # 检查学生的专业ID是否存在
        major_ids = {m['id'] for m in majors}
        for student in students:
            if student['major_id'] not in major_ids:
                errors.setdefault('students', []).append(
                    f"学生 {student['name']} 的专业ID {student['major_id']} 不存在"
                )
        
        return errors

# 主数据生成函数
def generate_complete_dataset(scale: str = 'large') -> Dict:
    """生成完整的测试数据集"""
    
    # 选择数据规模
    if scale == 'large':
        config = DATA_SCALE
    elif scale == 'medium':
        config = MEDIUM_SCALE
    else:
        config = SMALL_SCALE
    
    print(f"开始生成{scale}规模测试数据...")
    
    # 初始化生成器
    dept_gen = DepartmentGenerator()
    user_gen = UserGenerator()
    course_gen = CourseGenerator()
    facility_gen = FacilityGenerator()
    scenario_gen = ComplexScenarioGenerator()
    
    # 生成基础数据
    print("生成院系专业数据...")
    departments = dept_gen.generate_departments(config['departments'])
    majors = dept_gen.generate_majors(departments)
    
    print("生成用户数据...")
    students = user_gen.generate_students(config['students'], majors)
    teachers = user_gen.generate_teachers(config['teachers'], departments)
    
    print("生成课程数据...")
    courses = course_gen.generate_courses(config['courses'], departments, teachers)
    
    print("生成设施数据...")
    classrooms = facility_gen.generate_classrooms(config['classrooms'])
    time_slots = facility_gen.generate_time_slots()
    
    print("生成复杂场景数据...")
    enrollments = scenario_gen.generate_enrollment_data(students, courses)
    teacher_preferences = scenario_gen.generate_teacher_preferences(teachers)
    conflicts = scenario_gen.generate_conflict_scenarios(courses, teachers, classrooms)
    
    # 组装完整数据集
    dataset = {
        'departments': departments,
        'majors': majors,
        'students': students,
        'teachers': teachers,
        'courses': courses,
        'classrooms': classrooms,
        'time_slots': time_slots,
        'enrollments': enrollments,
        'teacher_preferences': teacher_preferences,
        'conflicts': conflicts,
        'metadata': {
            'scale': scale,
            'generated_at': datetime.now().isoformat(),
            'total_records': sum(len(v) if isinstance(v, list) else 0 for v in dataset.values()),
            'config': config
        }
    }
    
    print(f"数据生成完成！总计 {dataset['metadata']['total_records']} 条记录")
    
    return dataset

# 使用示例
if __name__ == "__main__":
    # 生成大规模测试数据
    large_dataset = generate_complete_dataset('large')
    
    # 导出数据
    exporter = DataExporter()
    exporter.export_to_json(large_dataset, 'large_test_data.json')
    exporter.export_to_sql(large_dataset, 'large_test_data.sql')
    
    # 验证数据完整性
    errors = exporter.validate_data_integrity(large_dataset)
    if errors:
        print("数据验证发现问题：", errors)
    else:
        print("数据验证通过！")
```

请按照以上要求生成大规模、真实、复杂的测试数据，确保能够充分验证排课算法的有效性。
