# 模块3：智能排课算法开发提示词

## 算法设计目标

你是一位资深的算法工程师，需要为校园课程表管理系统设计和实现高效、智能的排课算法。算法必须具备以下特性：

- **高效性**: 能够在合理时间内完成大规模排课任务
- **智能性**: 考虑多种约束条件和优化目标
- **灵活性**: 支持手动调整和增量更新
- **稳定性**: 算法运行稳定，结果可重现

## 核心算法模块

### 模块1：约束条件定义

**硬约束 (Hard Constraints)**:
```python
class HardConstraints:
    """硬约束条件 - 必须满足的条件"""
    
    @staticmethod
    def teacher_conflict_check(schedule: Schedule, new_assignment: Assignment) -> bool:
        """检查教师时间冲突"""
        teacher_id = new_assignment.teacher_id
        time_slot = new_assignment.time_slot
        day_of_week = new_assignment.day_of_week
        
        # 检查同一教师在同一时间是否已有课程
        existing_schedules = schedule.get_by_teacher_time(
            teacher_id, day_of_week, time_slot
        )
        return len(existing_schedules) == 0
    
    @staticmethod
    def classroom_conflict_check(schedule: Schedule, new_assignment: Assignment) -> bool:
        """检查教室时间冲突"""
        classroom_id = new_assignment.classroom_id
        time_slot = new_assignment.time_slot
        day_of_week = new_assignment.day_of_week
        
        # 检查同一教室在同一时间是否已被占用
        existing_schedules = schedule.get_by_classroom_time(
            classroom_id, day_of_week, time_slot
        )
        return len(existing_schedules) == 0
    
    @staticmethod
    def classroom_capacity_check(course: Course, classroom: Classroom) -> bool:
        """检查教室容量是否满足课程需求"""
        return classroom.capacity >= course.enrolled_students
    
    @staticmethod
    def prerequisite_check(course: Course, student_schedules: List[Schedule]) -> bool:
        """检查先修课程要求"""
        for prerequisite in course.prerequisites:
            if not any(s.course_id == prerequisite.id for s in student_schedules):
                return False
        return True
```

**软约束 (Soft Constraints)**:
```python
class SoftConstraints:
    """软约束条件 - 优化目标，可以违反但会降低方案质量"""
    
    @staticmethod
    def teacher_preference_score(assignment: Assignment, teacher: Teacher) -> float:
        """教师时间偏好评分"""
        time_slot = assignment.time_slot
        day_of_week = assignment.day_of_week
        
        # 获取教师偏好设置
        preference = teacher.time_preferences.get(day_of_week, {})
        return preference.get(time_slot, 0.5)  # 默认中性偏好
    
    @staticmethod
    def workload_balance_score(teacher: Teacher, current_load: int) -> float:
        """教师工作量平衡评分"""
        ideal_load = teacher.max_weekly_hours
        if current_load <= ideal_load:
            return 1.0 - (ideal_load - current_load) / ideal_load
        else:
            # 超负荷惩罚
            return max(0.0, 1.0 - (current_load - ideal_load) / ideal_load)
    
    @staticmethod
    def time_distribution_score(course_assignments: List[Assignment]) -> float:
        """课程时间分布均匀性评分"""
        if len(course_assignments) <= 1:
            return 1.0
        
        # 计算课程间隔的方差，间隔越均匀分数越高
        intervals = []
        sorted_assignments = sorted(course_assignments, 
                                  key=lambda x: (x.day_of_week, x.time_slot))
        
        for i in range(len(sorted_assignments) - 1):
            current = sorted_assignments[i]
            next_assignment = sorted_assignments[i + 1]
            interval = (next_assignment.day_of_week - current.day_of_week) * 10 + \
                      (next_assignment.time_slot - current.time_slot)
            intervals.append(interval)
        
        if not intervals:
            return 1.0
        
        variance = np.var(intervals)
        return 1.0 / (1.0 + variance)  # 方差越小，分数越高
```

### 模块2：遗传算法实现

```python
import random
import numpy as np
from typing import List, Tuple, Dict
from dataclasses import dataclass

@dataclass
class Individual:
    """个体 - 代表一个完整的排课方案"""
    assignments: List[Assignment]
    fitness: float = 0.0
    
    def calculate_fitness(self, constraints: ConstraintManager) -> float:
        """计算个体适应度"""
        hard_violations = 0
        soft_score = 0.0
        
        # 检查硬约束违反情况
        for assignment in self.assignments:
            if not constraints.check_hard_constraints(assignment, self.assignments):
                hard_violations += 1
        
        # 如果有硬约束违反，适应度为负值
        if hard_violations > 0:
            self.fitness = -hard_violations * 1000
            return self.fitness
        
        # 计算软约束得分
        soft_score = constraints.calculate_soft_score(self.assignments)
        self.fitness = soft_score
        return self.fitness

class GeneticAlgorithm:
    """遗传算法排课器"""
    
    def __init__(self, 
                 population_size: int = 100,
                 mutation_rate: float = 0.1,
                 crossover_rate: float = 0.8,
                 max_generations: int = 1000):
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.max_generations = max_generations
        self.constraints = ConstraintManager()
    
    def initialize_population(self, courses: List[Course], 
                            teachers: List[Teacher],
                            classrooms: List[Classroom]) -> List[Individual]:
        """初始化种群"""
        population = []
        
        for _ in range(self.population_size):
            individual = self.create_random_individual(courses, teachers, classrooms)
            population.append(individual)
        
        return population
    
    def create_random_individual(self, courses: List[Course],
                               teachers: List[Teacher],
                               classrooms: List[Classroom]) -> Individual:
        """创建随机个体"""
        assignments = []
        
        for course in courses:
            # 为每门课程随机分配教师、教室和时间
            teacher = random.choice([t for t in teachers if course.id in t.qualified_courses])
            classroom = random.choice([c for c in classrooms if c.capacity >= course.enrolled_students])
            
            # 随机选择时间段
            day_of_week = random.randint(1, 5)  # 周一到周五
            time_slot = random.randint(1, 10)   # 10个时间段
            
            assignment = Assignment(
                course_id=course.id,
                teacher_id=teacher.id,
                classroom_id=classroom.id,
                day_of_week=day_of_week,
                time_slot=time_slot
            )
            assignments.append(assignment)
        
        return Individual(assignments)
    
    def selection(self, population: List[Individual]) -> List[Individual]:
        """选择操作 - 锦标赛选择"""
        selected = []
        tournament_size = 3
        
        for _ in range(len(population)):
            tournament = random.sample(population, tournament_size)
            winner = max(tournament, key=lambda x: x.fitness)
            selected.append(winner)
        
        return selected
    
    def crossover(self, parent1: Individual, parent2: Individual) -> Tuple[Individual, Individual]:
        """交叉操作 - 单点交叉"""
        if random.random() > self.crossover_rate:
            return parent1, parent2
        
        crossover_point = random.randint(1, len(parent1.assignments) - 1)
        
        child1_assignments = (parent1.assignments[:crossover_point] + 
                            parent2.assignments[crossover_point:])
        child2_assignments = (parent2.assignments[:crossover_point] + 
                            parent1.assignments[crossover_point:])
        
        return Individual(child1_assignments), Individual(child2_assignments)
    
    def mutation(self, individual: Individual, 
                teachers: List[Teacher], 
                classrooms: List[Classroom]) -> Individual:
        """变异操作"""
        if random.random() > self.mutation_rate:
            return individual
        
        # 随机选择一个课程进行变异
        mutation_index = random.randint(0, len(individual.assignments) - 1)
        assignment = individual.assignments[mutation_index]
        
        # 随机改变教师、教室或时间
        mutation_type = random.choice(['teacher', 'classroom', 'time'])
        
        if mutation_type == 'teacher':
            qualified_teachers = [t for t in teachers 
                                if assignment.course_id in t.qualified_courses]
            if qualified_teachers:
                assignment.teacher_id = random.choice(qualified_teachers).id
        
        elif mutation_type == 'classroom':
            suitable_classrooms = [c for c in classrooms 
                                 if c.capacity >= assignment.course.enrolled_students]
            if suitable_classrooms:
                assignment.classroom_id = random.choice(suitable_classrooms).id
        
        elif mutation_type == 'time':
            assignment.day_of_week = random.randint(1, 5)
            assignment.time_slot = random.randint(1, 10)
        
        return individual
    
    def evolve(self, courses: List[Course], 
              teachers: List[Teacher],
              classrooms: List[Classroom]) -> Individual:
        """进化过程"""
        # 初始化种群
        population = self.initialize_population(courses, teachers, classrooms)
        
        # 计算初始适应度
        for individual in population:
            individual.calculate_fitness(self.constraints)
        
        best_individual = max(population, key=lambda x: x.fitness)
        best_fitness_history = [best_individual.fitness]
        
        for generation in range(self.max_generations):
            # 选择
            selected = self.selection(population)
            
            # 交叉和变异
            new_population = []
            for i in range(0, len(selected), 2):
                parent1 = selected[i]
                parent2 = selected[i + 1] if i + 1 < len(selected) else selected[0]
                
                child1, child2 = self.crossover(parent1, parent2)
                child1 = self.mutation(child1, teachers, classrooms)
                child2 = self.mutation(child2, teachers, classrooms)
                
                new_population.extend([child1, child2])
            
            # 计算新种群适应度
            for individual in new_population:
                individual.calculate_fitness(self.constraints)
            
            # 精英保留
            population = sorted(new_population, key=lambda x: x.fitness, reverse=True)
            population = population[:self.population_size]
            
            # 更新最佳个体
            current_best = population[0]
            if current_best.fitness > best_individual.fitness:
                best_individual = current_best
            
            best_fitness_history.append(best_individual.fitness)
            
            # 早停条件
            if generation > 50 and len(set(best_fitness_history[-50:])) == 1:
                print(f"Early stopping at generation {generation}")
                break
            
            if generation % 100 == 0:
                print(f"Generation {generation}: Best fitness = {best_individual.fitness}")
        
        return best_individual
```

### 模块3：启发式算法实现

```python
class GreedyScheduler:
    """贪心算法排课器"""
    
    def __init__(self):
        self.constraints = ConstraintManager()
    
    def schedule(self, courses: List[Course], 
                teachers: List[Teacher],
                classrooms: List[Classroom]) -> List[Assignment]:
        """贪心排课算法"""
        assignments = []
        
        # 按优先级排序课程
        sorted_courses = self.prioritize_courses(courses)
        
        for course in sorted_courses:
            best_assignment = self.find_best_assignment(
                course, teachers, classrooms, assignments
            )
            
            if best_assignment:
                assignments.append(best_assignment)
            else:
                print(f"Warning: Could not schedule course {course.name}")
        
        return assignments
    
    def prioritize_courses(self, courses: List[Course]) -> List[Course]:
        """课程优先级排序"""
        # 按以下优先级排序：
        # 1. 必修课优先于选修课
        # 2. 学分高的课程优先
        # 3. 选课人数多的课程优先
        return sorted(courses, key=lambda c: (
            -int(c.is_required),  # 必修课优先
            -c.credits,           # 学分高优先
            -c.enrolled_students  # 选课人数多优先
        ))
    
    def find_best_assignment(self, course: Course,
                           teachers: List[Teacher],
                           classrooms: List[Classroom],
                           existing_assignments: List[Assignment]) -> Assignment:
        """为课程找到最佳分配"""
        best_assignment = None
        best_score = -1
        
        # 获取合格的教师
        qualified_teachers = [t for t in teachers 
                            if course.id in t.qualified_courses]
        
        # 获取合适的教室
        suitable_classrooms = [c for c in classrooms 
                             if c.capacity >= course.enrolled_students]
        
        # 尝试所有可能的组合
        for teacher in qualified_teachers:
            for classroom in suitable_classrooms:
                for day in range(1, 6):  # 周一到周五
                    for time_slot in range(1, 11):  # 10个时间段
                        
                        assignment = Assignment(
                            course_id=course.id,
                            teacher_id=teacher.id,
                            classroom_id=classroom.id,
                            day_of_week=day,
                            time_slot=time_slot
                        )
                        
                        # 检查硬约束
                        if self.constraints.check_hard_constraints(
                            assignment, existing_assignments
                        ):
                            # 计算软约束得分
                            score = self.constraints.calculate_assignment_score(
                                assignment, existing_assignments
                            )
                            
                            if score > best_score:
                                best_score = score
                                best_assignment = assignment
        
        return best_assignment
```

### 模块4：冲突检测与解决

```python
class ConflictDetector:
    """冲突检测器"""
    
    def detect_conflicts(self, assignments: List[Assignment]) -> List[Conflict]:
        """检测所有冲突"""
        conflicts = []
        
        # 教师时间冲突
        conflicts.extend(self.detect_teacher_conflicts(assignments))
        
        # 教室时间冲突
        conflicts.extend(self.detect_classroom_conflicts(assignments))
        
        # 学生课程冲突
        conflicts.extend(self.detect_student_conflicts(assignments))
        
        return conflicts
    
    def detect_teacher_conflicts(self, assignments: List[Assignment]) -> List[Conflict]:
        """检测教师时间冲突"""
        conflicts = []
        teacher_schedule = {}
        
        for assignment in assignments:
            key = (assignment.teacher_id, assignment.day_of_week, assignment.time_slot)
            
            if key in teacher_schedule:
                conflict = Conflict(
                    type='teacher_time',
                    assignments=[teacher_schedule[key], assignment],
                    description=f"教师 {assignment.teacher_id} 在 {assignment.day_of_week} 第{assignment.time_slot}节 有时间冲突"
                )
                conflicts.append(conflict)
            else:
                teacher_schedule[key] = assignment
        
        return conflicts
    
    def resolve_conflicts(self, conflicts: List[Conflict],
                         teachers: List[Teacher],
                         classrooms: List[Classroom]) -> List[Assignment]:
        """解决冲突"""
        resolved_assignments = []
        
        for conflict in conflicts:
            if conflict.type == 'teacher_time':
                resolved = self.resolve_teacher_conflict(
                    conflict, teachers, classrooms
                )
                resolved_assignments.extend(resolved)
        
        return resolved_assignments

class ConflictResolver:
    """冲突解决器"""
    
    def __init__(self):
        self.constraints = ConstraintManager()
    
    def resolve_teacher_conflict(self, conflict: Conflict,
                               teachers: List[Teacher],
                               classrooms: List[Classroom]) -> List[Assignment]:
        """解决教师时间冲突"""
        conflicting_assignments = conflict.assignments
        
        # 策略1: 重新分配时间
        for assignment in conflicting_assignments:
            new_time = self.find_alternative_time(
                assignment, teachers, classrooms
            )
            if new_time:
                assignment.day_of_week = new_time[0]
                assignment.time_slot = new_time[1]
                return [assignment]
        
        # 策略2: 重新分配教师
        for assignment in conflicting_assignments:
            alternative_teacher = self.find_alternative_teacher(
                assignment, teachers
            )
            if alternative_teacher:
                assignment.teacher_id = alternative_teacher.id
                return [assignment]
        
        return conflicting_assignments
```

### 模块5：算法性能优化

```python
class ScheduleOptimizer:
    """排课优化器"""
    
    def __init__(self):
        self.cache = {}
    
    def optimize_schedule(self, initial_schedule: List[Assignment]) -> List[Assignment]:
        """优化现有排课方案"""
        current_schedule = initial_schedule.copy()
        
        # 局部搜索优化
        improved = True
        iteration = 0
        max_iterations = 1000
        
        while improved and iteration < max_iterations:
            improved = False
            iteration += 1
            
            # 尝试交换操作
            for i in range(len(current_schedule)):
                for j in range(i + 1, len(current_schedule)):
                    new_schedule = self.swap_assignments(
                        current_schedule, i, j
                    )
                    
                    if self.is_better_schedule(new_schedule, current_schedule):
                        current_schedule = new_schedule
                        improved = True
                        break
                
                if improved:
                    break
            
            # 尝试重新分配操作
            if not improved:
                for i in range(len(current_schedule)):
                    new_schedule = self.reassign_course(current_schedule, i)
                    
                    if self.is_better_schedule(new_schedule, current_schedule):
                        current_schedule = new_schedule
                        improved = True
                        break
        
        return current_schedule
    
    def parallel_genetic_algorithm(self, courses: List[Course],
                                 teachers: List[Teacher],
                                 classrooms: List[Classroom],
                                 num_processes: int = 4) -> Individual:
        """并行遗传算法"""
        from multiprocessing import Pool, Manager
        
        manager = Manager()
        shared_best = manager.dict()
        shared_best['fitness'] = float('-inf')
        shared_best['individual'] = None
        
        def run_ga_process(process_id):
            ga = GeneticAlgorithm(
                population_size=50,
                max_generations=250
            )
            best = ga.evolve(courses, teachers, classrooms)
            
            if best.fitness > shared_best['fitness']:
                shared_best['fitness'] = best.fitness
                shared_best['individual'] = best
            
            return best
        
        with Pool(num_processes) as pool:
            results = pool.map(run_ga_process, range(num_processes))
        
        return shared_best['individual']
```

## 算法集成与调用

```python
class SchedulingEngine:
    """排课引擎 - 集成所有算法"""
    
    def __init__(self):
        self.genetic_algorithm = GeneticAlgorithm()
        self.greedy_scheduler = GreedyScheduler()
        self.conflict_detector = ConflictDetector()
        self.optimizer = ScheduleOptimizer()
    
    def generate_schedule(self, courses: List[Course],
                         teachers: List[Teacher],
                         classrooms: List[Classroom],
                         algorithm: str = 'hybrid') -> ScheduleResult:
        """生成课程表"""
        
        if algorithm == 'genetic':
            best_individual = self.genetic_algorithm.evolve(
                courses, teachers, classrooms
            )
            assignments = best_individual.assignments
        
        elif algorithm == 'greedy':
            assignments = self.greedy_scheduler.schedule(
                courses, teachers, classrooms
            )
        
        elif algorithm == 'hybrid':
            # 混合算法：先用贪心算法生成初始解，再用遗传算法优化
            initial_assignments = self.greedy_scheduler.schedule(
                courses, teachers, classrooms
            )
            
            # 使用初始解作为遗传算法的种子
            optimized_individual = self.genetic_algorithm.evolve_with_seed(
                courses, teachers, classrooms, initial_assignments
            )
            assignments = optimized_individual.assignments
        
        # 冲突检测
        conflicts = self.conflict_detector.detect_conflicts(assignments)
        
        # 最终优化
        if not conflicts:
            assignments = self.optimizer.optimize_schedule(assignments)
        
        return ScheduleResult(
            assignments=assignments,
            conflicts=conflicts,
            fitness_score=self.calculate_overall_fitness(assignments)
        )
```

请按照以上算法设计实现智能排课系统，确保算法的高效性和实用性。
